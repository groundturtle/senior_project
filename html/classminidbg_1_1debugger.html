<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: minidbg::debugger类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceminidbg.html">minidbg</a></li><li class="navelem"><a class="el" href="classminidbg_1_1debugger.html">debugger</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classminidbg_1_1debugger-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">minidbg::debugger类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>调试器类，用于跟踪和调试程序执行。  
 <a href="classminidbg_1_1debugger.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="debugger_8hpp_source.html">debugger.hpp</a>&gt;</code></p>
<div class="dynheader">
minidbg::debugger 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger__coll__graph.png" border="0" usemap="#minidbg_1_1debugger_coll__map" alt="Collaboration graph"/></div>
<map name="minidbg_1_1debugger_coll__map" id="minidbg_1_1debugger_coll__map">
<area shape="rect" title="调试器类，用于跟踪和调试程序执行。" alt="" coords="463,189,679,575"/>
<area shape="rect" title=" " alt="" coords="5,20,80,97"/>
<area shape="rect" title=" " alt="" coords="105,13,271,105"/>
<area shape="rect" title=" " alt="" coords="295,20,454,97"/>
<area shape="rect" title=" " alt="" coords="479,20,537,97"/>
<area shape="rect" title=" " alt="" coords="562,5,721,112"/>
<area shape="rect" title=" " alt="" coords="745,20,799,97"/>
<area shape="rect" title=" " alt="" coords="824,20,883,97"/>
<area shape="rect" title=" " alt="" coords="965,20,1003,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a634ab39fc9fbfa7c213629aaa9b0a9eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a634ab39fc9fbfa7c213629aaa9b0a9eb">kill_prog</a> ()</td></tr>
<tr class="memdesc:a634ab39fc9fbfa7c213629aaa9b0a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">终止被调试程序  <a href="classminidbg_1_1debugger.html#a634ab39fc9fbfa7c213629aaa9b0a9eb">更多...</a><br /></td></tr>
<tr class="separator:a634ab39fc9fbfa7c213629aaa9b0a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91741cf22396213a7f23dfa440d52a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, u_int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ad91741cf22396213a7f23dfa440d52a6">get_ram_vct</a> ()</td></tr>
<tr class="memdesc:ad91741cf22396213a7f23dfa440d52a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取程序中各个寄存器的值。  <a href="classminidbg_1_1debugger.html#ad91741cf22396213a7f23dfa440d52a6">更多...</a><br /></td></tr>
<tr class="separator:ad91741cf22396213a7f23dfa440d52a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d63db538666ebb38ea899d1821a370b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a8d63db538666ebb38ea899d1821a370b">get_src_line</a> ()</td></tr>
<tr class="memdesc:a8d63db538666ebb38ea899d1821a370b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前源代码行号。  <a href="classminidbg_1_1debugger.html#a8d63db538666ebb38ea899d1821a370b">更多...</a><br /></td></tr>
<tr class="separator:a8d63db538666ebb38ea899d1821a370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782a179d08d545c03c989f54f7aa3127"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127">get_pc</a> ()</td></tr>
<tr class="memdesc:a782a179d08d545c03c989f54f7aa3127"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前程序计数器（PC）的值。  <a href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127">更多...</a><br /></td></tr>
<tr class="separator:a782a179d08d545c03c989f54f7aa3127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1ba35f894fac6403185e0acdd4536"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#abbf1ba35f894fac6403185e0acdd4536">get_rbp</a> ()</td></tr>
<tr class="memdesc:abbf1ba35f894fac6403185e0acdd4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前基址寄存器（RBP）的值。  <a href="classminidbg_1_1debugger.html#abbf1ba35f894fac6403185e0acdd4536">更多...</a><br /></td></tr>
<tr class="separator:abbf1ba35f894fac6403185e0acdd4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7326411326dc7be2ca1780747b73c668"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a7326411326dc7be2ca1780747b73c668">get_rsp</a> ()</td></tr>
<tr class="memdesc:a7326411326dc7be2ca1780747b73c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前栈指针寄存器（RSP）的值。  <a href="classminidbg_1_1debugger.html#a7326411326dc7be2ca1780747b73c668">更多...</a><br /></td></tr>
<tr class="separator:a7326411326dc7be2ca1780747b73c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c019420f24ef96e95a145b3a62c5973"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; uint64_t, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a5c019420f24ef96e95a145b3a62c5973">get_backtrace_vct</a> ()</td></tr>
<tr class="memdesc:a5c019420f24ef96e95a145b3a62c5973"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前线程的函数调用链回溯信息息。  <a href="classminidbg_1_1debugger.html#a5c019420f24ef96e95a145b3a62c5973">更多...</a><br /></td></tr>
<tr class="separator:a5c019420f24ef96e95a145b3a62c5973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b0db8714bdea3a20003d0a0fc3cb6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; uint64_t, std::vector&lt; uint8_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a622b0db8714bdea3a20003d0a0fc3cb6">get_global_stack_vct</a> (uint64_t start_addr, uint64_t end_addr)</td></tr>
<tr class="memdesc:a622b0db8714bdea3a20003d0a0fc3cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取全局堆栈信息。  <a href="classminidbg_1_1debugger.html#a622b0db8714bdea3a20003d0a0fc3cb6">更多...</a><br /></td></tr>
<tr class="separator:a622b0db8714bdea3a20003d0a0fc3cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115f14a7fc9aea645df019c541d3aa60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a115f14a7fc9aea645df019c541d3aa60">debugger</a> ()</td></tr>
<tr class="separator:a115f14a7fc9aea645df019c541d3aa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644b99a4260aa9c5373a1c0b375cf9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a644b99a4260aa9c5373a1c0b375cf9c5">initDbg</a> (std::string prog_name, pid_t pid)</td></tr>
<tr class="memdesc:a644b99a4260aa9c5373a1c0b375cf9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化mini调试器。  <a href="classminidbg_1_1debugger.html#a644b99a4260aa9c5373a1c0b375cf9c5">更多...</a><br /></td></tr>
<tr class="separator:a644b99a4260aa9c5373a1c0b375cf9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2686dd54e6d39c86d0321bd617b115d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4">continue_execution</a> ()</td></tr>
<tr class="memdesc:a2686dd54e6d39c86d0321bd617b115d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b" title="检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue.">step_over()</a>_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行  <a href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4">更多...</a><br /></td></tr>
<tr class="separator:a2686dd54e6d39c86d0321bd617b115d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f65554d4750e16bc1c01b046edb0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aab4f65554d4750e16bc1c01b046edb0d">break_execution</a> (std::string command)</td></tr>
<tr class="memdesc:aab4f65554d4750e16bc1c01b046edb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据命令设置断点  <a href="classminidbg_1_1debugger.html#aab4f65554d4750e16bc1c01b046edb0d">更多...</a><br /></td></tr>
<tr class="separator:aab4f65554d4750e16bc1c01b046edb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06d1327a1c6b32427035bee28cc83dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aa06d1327a1c6b32427035bee28cc83dd">next_execution</a> ()</td></tr>
<tr class="separator:aa06d1327a1c6b32427035bee28cc83dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9075df44cb4df2729c1036c035b0c85c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a9075df44cb4df2729c1036c035b0c85c">finish_execution</a> ()</td></tr>
<tr class="separator:a9075df44cb4df2729c1036c035b0c85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb73e8080bbd2fa305b8d383b4ddd3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#acb73e8080bbd2fa305b8d383b4ddd3e4">step_into_execution</a> ()</td></tr>
<tr class="separator:acb73e8080bbd2fa305b8d383b4ddd3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff1e34730485fa0ac3900fb8c88d448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aaff1e34730485fa0ac3900fb8c88d448">si_execution</a> ()</td></tr>
<tr class="separator:aaff1e34730485fa0ac3900fb8c88d448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:aba207285db39ae79e905ce84b3d4b304"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structminidbg_1_1asm__head.html">asm_head</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aba207285db39ae79e905ce84b3d4b304">m_asm_vct</a></td></tr>
<tr class="separator:aba207285db39ae79e905ce84b3d4b304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a12eeb3fc31453ba9e54e2c57aafa4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a17a12eeb3fc31453ba9e54e2c57aafa4">m_src_vct</a></td></tr>
<tr class="separator:a17a12eeb3fc31453ba9e54e2c57aafa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:ab5128ad097ff8fdb0cdb5bf17b979a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ab5128ad097ff8fdb0cdb5bf17b979a58">handle_command</a> (const std::string &amp;line)</td></tr>
<tr class="memdesc:ab5128ad097ff8fdb0cdb5bf17b979a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理用户输入的调试器命令，并执行相应操作  <a href="classminidbg_1_1debugger.html#ab5128ad097ff8fdb0cdb5bf17b979a58">更多...</a><br /></td></tr>
<tr class="separator:ab5128ad097ff8fdb0cdb5bf17b979a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5679e71844ee8af9206377b3f9d61f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82">handle_sigtrap</a> (siginfo_t info)</td></tr>
<tr class="memdesc:a5679e71844ee8af9206377b3f9d61f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理： <br  />
  <a href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82">更多...</a><br /></td></tr>
<tr class="separator:a5679e71844ee8af9206377b3f9d61f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace071934f7fedb171618a830e0b2f856"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856">offset_load_address</a> (uint64_t addr)</td></tr>
<tr class="memdesc:ace071934f7fedb171618a830e0b2f856"><td class="mdescLeft">&#160;</td><td class="mdescRight">从实际地址转换为相对地址  <a href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856">更多...</a><br /></td></tr>
<tr class="separator:ace071934f7fedb171618a830e0b2f856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec3114b66ec64774be46873a97e307"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307">offset_dwarf_address</a> (uint64_t addr)</td></tr>
<tr class="memdesc:aadec3114b66ec64774be46873a97e307"><td class="mdescLeft">&#160;</td><td class="mdescRight">将相对地址转换为实际地址  <a href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307">更多...</a><br /></td></tr>
<tr class="separator:aadec3114b66ec64774be46873a97e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e26f0c99ba1bd0390cf2dba4e24a29"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29">get_offset_pc</a> ()</td></tr>
<tr class="separator:a56e26f0c99ba1bd0390cf2dba4e24a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabde5dd3945efd3cffdec4e6cd245cff"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff">read_memory</a> (uint64_t address)</td></tr>
<tr class="separator:aabde5dd3945efd3cffdec4e6cd245cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111b5ed151d51b9e0a8480a0a845286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a8111b5ed151d51b9e0a8480a0a845286">write_memory</a> (uint64_t address, uint64_t value)</td></tr>
<tr class="separator:a8111b5ed151d51b9e0a8480a0a845286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33de60b0cf721c1fd24e5a3b5159e205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205">set_breakpoint_at_address</a> (std::intptr_t addr)</td></tr>
<tr class="memdesc:a33de60b0cf721c1fd24e5a3b5159e205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set breakpoint by address  <a href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205">更多...</a><br /></td></tr>
<tr class="separator:a33de60b0cf721c1fd24e5a3b5159e205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddaa3f5b34d13a5c22b49ebb6ec58e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#adddaa3f5b34d13a5c22b49ebb6ec58e4">dump_registers</a> ()</td></tr>
<tr class="memdesc:adddaa3f5b34d13a5c22b49ebb6ec58e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">打印目标进程的寄存器信息 <br  />
  <a href="classminidbg_1_1debugger.html#adddaa3f5b34d13a5c22b49ebb6ec58e4">更多...</a><br /></td></tr>
<tr class="separator:adddaa3f5b34d13a5c22b49ebb6ec58e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6efac5e854a13f0bc1e6a07a8a208d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2">set_pc</a> (uint64_t pc)</td></tr>
<tr class="separator:ab6efac5e854a13f0bc1e6a07a8a208d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2972e37458f63870e18c34f0a44bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1">wait_for_signal</a> ()</td></tr>
<tr class="memdesc:ade2972e37458f63870e18c34f0a44bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">等待目标进程发送信号并做出相应处理.  <a href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1">更多...</a><br /></td></tr>
<tr class="separator:ade2972e37458f63870e18c34f0a44bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc81497da4da399495135ed332fe01e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7">step_over_breakpoint</a> ()</td></tr>
<tr class="memdesc:acc81497da4da399495135ed332fe01e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。  <a href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7">更多...</a><br /></td></tr>
<tr class="separator:acc81497da4da399495135ed332fe01e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8a4061ffd8420395b9d8a83358567a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structminidbg_1_1asm__head.html">asm_head</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a1f8a4061ffd8420395b9d8a83358567a">get_function_from_pc</a> (uint64_t pc)</td></tr>
<tr class="memdesc:a1f8a4061ffd8420395b9d8a83358567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">确定当前指令所属的函数  <a href="classminidbg_1_1debugger.html#a1f8a4061ffd8420395b9d8a83358567a">更多...</a><br /></td></tr>
<tr class="separator:a1f8a4061ffd8420395b9d8a83358567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a72f56b837540af184db2c53de4aef"><td class="memItemLeft" align="right" valign="top">dwarf::line_table::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef">get_line_entry_from_pc</a> (uint64_t pc)</td></tr>
<tr class="memdesc:ab0a72f56b837540af184db2c53de4aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the line entry from pc object  <a href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef">更多...</a><br /></td></tr>
<tr class="separator:ab0a72f56b837540af184db2c53de4aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5317fd19f40e33920e7235bb4406b460"><td class="memItemLeft" align="right" valign="top">dwarf::line_table::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a5317fd19f40e33920e7235bb4406b460">get_next_line_entry_from_pc</a> (uint64_t pc)</td></tr>
<tr class="memdesc:a5317fd19f40e33920e7235bb4406b460"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据程序计数器获取下一行的DWARF调试信息。  <a href="classminidbg_1_1debugger.html#a5317fd19f40e33920e7235bb4406b460">更多...</a><br /></td></tr>
<tr class="separator:a5317fd19f40e33920e7235bb4406b460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4875fc7f36cb21d20c02bc0778f986d5"><td class="memItemLeft" align="right" valign="top">siginfo_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5">get_signal_info</a> ()</td></tr>
<tr class="memdesc:a4875fc7f36cb21d20c02bc0778f986d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the signal info  <a href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5">更多...</a><br /></td></tr>
<tr class="separator:a4875fc7f36cb21d20c02bc0778f986d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ff213c04734e537744be8a3e915345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345">single_step_instruction</a> ()</td></tr>
<tr class="memdesc:ae9ff213c04734e537744be8a3e915345"><td class="mdescLeft">&#160;</td><td class="mdescRight">向子进程发送信号，让子进程只执行一条指令  <a href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345">更多...</a><br /></td></tr>
<tr class="separator:ae9ff213c04734e537744be8a3e915345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c395083ae6156ababe81561ab17a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76">single_step_instruction_with_breakpoint_check</a> ()</td></tr>
<tr class="memdesc:a60c395083ae6156ababe81561ab17a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()  <a href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76">更多...</a><br /></td></tr>
<tr class="separator:a60c395083ae6156ababe81561ab17a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd3a2d4d8a89d1c61e516f0d0db128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128">remove_breakpoint</a> (std::intptr_t addr)</td></tr>
<tr class="memdesc:a57cd3a2d4d8a89d1c61e516f0d0db128"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除地址addr上的断点。  <a href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128">更多...</a><br /></td></tr>
<tr class="separator:a57cd3a2d4d8a89d1c61e516f0d0db128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c19e64daba632bf0807d58bff713f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a16c19e64daba632bf0807d58bff713f7">step_out</a> ()</td></tr>
<tr class="memdesc:a16c19e64daba632bf0807d58bff713f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">跳出函数：从rbp获取返回地址，检查是否有断点，无则设置，然后continue；如刚设置了断点，则去除，如原有则不动。  <a href="classminidbg_1_1debugger.html#a16c19e64daba632bf0807d58bff713f7">更多...</a><br /></td></tr>
<tr class="separator:a16c19e64daba632bf0807d58bff713f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f22ffa07e4cf1d70480573c2075328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a36f22ffa07e4cf1d70480573c2075328">step_in</a> ()</td></tr>
<tr class="memdesc:a36f22ffa07e4cf1d70480573c2075328"><td class="mdescLeft">&#160;</td><td class="mdescRight">单步进入/进入到下一个源代码行: 循环执行单条指令，源代码行号发生变化，循环结束  <a href="classminidbg_1_1debugger.html#a36f22ffa07e4cf1d70480573c2075328">更多...</a><br /></td></tr>
<tr class="separator:a36f22ffa07e4cf1d70480573c2075328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08ae391b77f28a593e435516dc2f50b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b">step_over</a> ()</td></tr>
<tr class="memdesc:aa08ae391b77f28a593e435516dc2f50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue.  <a href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b">更多...</a><br /></td></tr>
<tr class="separator:aa08ae391b77f28a593e435516dc2f50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e95fd23fd5391089f97a198c04c8b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#ad4e95fd23fd5391089f97a198c04c8b5">set_breakpoint_at_function</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad4e95fd23fd5391089f97a198c04c8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the breakpoint at function object  <a href="classminidbg_1_1debugger.html#ad4e95fd23fd5391089f97a198c04c8b5">更多...</a><br /></td></tr>
<tr class="separator:ad4e95fd23fd5391089f97a198c04c8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3953940c630495e035444371643727aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a3953940c630495e035444371643727aa">set_breakpoint_at_source_file</a> (const std::string &amp;file, unsigned line)</td></tr>
<tr class="memdesc:a3953940c630495e035444371643727aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过'<a href="file:line'">file:line'</a>形式的命令设置断点。  <a href="classminidbg_1_1debugger.html#a3953940c630495e035444371643727aa">更多...</a><br /></td></tr>
<tr class="separator:a3953940c630495e035444371643727aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268b73756c673c5a34cf25030bff03a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structsymboltype_1_1symbol.html">symboltype::symbol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a268b73756c673c5a34cf25030bff03a1">lookup_symbol</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a268b73756c673c5a34cf25030bff03a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">查找符号, <a class="el" href="classminidbg_1_1debugger.html#ab5128ad097ff8fdb0cdb5bf17b979a58" title="处理用户输入的调试器命令，并执行相应操作">handle_command()</a> 中使用.  <a href="classminidbg_1_1debugger.html#a268b73756c673c5a34cf25030bff03a1">更多...</a><br /></td></tr>
<tr class="separator:a268b73756c673c5a34cf25030bff03a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16b14e2a5c30f85a19b60dfed2436ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#aa16b14e2a5c30f85a19b60dfed2436ee">initialise_load_address</a> ()</td></tr>
<tr class="memdesc:aa16b14e2a5c30f85a19b60dfed2436ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化  <a href="classminidbg_1_1debugger.html#aa16b14e2a5c30f85a19b60dfed2436ee">更多...</a><br /></td></tr>
<tr class="separator:aa16b14e2a5c30f85a19b60dfed2436ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d445a16899ac9ced43f17bc61e5ce20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a6d445a16899ac9ced43f17bc61e5ce20">initialise_load_asm</a> ()</td></tr>
<tr class="memdesc:a6d445a16899ac9ced43f17bc61e5ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">加载汇编数据到m_asm_vct向量中  <a href="classminidbg_1_1debugger.html#a6d445a16899ac9ced43f17bc61e5ce20">更多...</a><br /></td></tr>
<tr class="separator:a6d445a16899ac9ced43f17bc61e5ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dff0e30d6837427da037845dca7516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a61dff0e30d6837427da037845dca7516">initialise_run_objdump</a> ()</td></tr>
<tr class="memdesc:a61dff0e30d6837427da037845dca7516"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用 objdump 命令生成反汇编代码  <a href="classminidbg_1_1debugger.html#a61dff0e30d6837427da037845dca7516">更多...</a><br /></td></tr>
<tr class="separator:a61dff0e30d6837427da037845dca7516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859bd0fa6bf7b2981ca554be9d13505b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a859bd0fa6bf7b2981ca554be9d13505b">initialise_load_src</a> ()</td></tr>
<tr class="memdesc:a859bd0fa6bf7b2981ca554be9d13505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">逐行读取源码到m_src_vct向量中  <a href="classminidbg_1_1debugger.html#a859bd0fa6bf7b2981ca554be9d13505b">更多...</a><br /></td></tr>
<tr class="separator:a859bd0fa6bf7b2981ca554be9d13505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:a180f020ca79e07ea89d05e48434f1696"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a180f020ca79e07ea89d05e48434f1696">m_prog_name</a></td></tr>
<tr class="separator:a180f020ca79e07ea89d05e48434f1696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd8e6f638de0139c3ddad334b2a4d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a89cd8e6f638de0139c3ddad334b2a4d9">m_asm_name</a></td></tr>
<tr class="separator:a89cd8e6f638de0139c3ddad334b2a4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a30786c73dd4790c18db6f49802950d"><td class="memItemLeft" align="right" valign="top">pid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a1a30786c73dd4790c18db6f49802950d">m_pid</a></td></tr>
<tr class="separator:a1a30786c73dd4790c18db6f49802950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce554a29ebf07ec4ae259facc08af4"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::intptr_t, <a class="el" href="classminidbg_1_1breakpoint.html">breakpoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a1cce554a29ebf07ec4ae259facc08af4">m_breakpoints</a></td></tr>
<tr class="separator:a1cce554a29ebf07ec4ae259facc08af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702325100d56cf362bcd1668250614d7"><td class="memItemLeft" align="right" valign="top">dwarf::dwarf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a702325100d56cf362bcd1668250614d7">m_dwarf</a></td></tr>
<tr class="separator:a702325100d56cf362bcd1668250614d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f21939a0c73f068627c153828dc2a6"><td class="memItemLeft" align="right" valign="top">elf::elf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a92f21939a0c73f068627c153828dc2a6">m_elf</a></td></tr>
<tr class="separator:a92f21939a0c73f068627c153828dc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4639149d22529617f5a694ee40a5cf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classminidbg_1_1debugger.html#a4a4639149d22529617f5a694ee40a5cf">m_load_address</a></td></tr>
<tr class="separator:a4a4639149d22529617f5a694ee40a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>调试器类，用于跟踪和调试程序执行。 </p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a115f14a7fc9aea645df019c541d3aa60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115f14a7fc9aea645df019c541d3aa60">&#9670;&nbsp;</a></span>debugger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">minidbg::debugger::debugger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="aab4f65554d4750e16bc1c01b046edb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4f65554d4750e16bc1c01b046edb0d">&#9670;&nbsp;</a></span>break_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::break_execution </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据命令设置断点 </p>
<p>支持以下三种格式的断点设置：</p><ol type="1">
<li>以十六进制地址开头的格式，如 <code>0xADDRESS</code>。</li>
<li>文件名和行号的格式，如 <code>&lt;filename&gt;:&lt;line&gt;</code>。</li>
<li>函数名的格式，如 <code>&lt;function_name&gt;</code>。</li>
</ol>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>用户输入的设置断点的命令</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>目前版本仅在 'main' 函数中使用。 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_aab4f65554d4750e16bc1c01b046edb0d_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_aab4f65554d4750e16bc1c01b046edb0d_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_aab4f65554d4750e16bc1c01b046edb0d_cgraph" id="classminidbg_1_1debugger_aab4f65554d4750e16bc1c01b046edb0d_cgraph">
<area shape="rect" title="根据命令设置断点" alt="" coords="5,136,157,177"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="469,136,667,177"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ad4e95fd23fd5391089f97a198c04c8b5" title="Set the breakpoint at function object" alt="" coords="214,41,413,83"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a3953940c630495e035444371643727aa" title="通过&#39;file:line&#39;形式的命令设置断点。" alt="" coords="205,107,421,148"/>
<area shape="rect" href="namespaceminidbg.html#a53e4cc1dcf1b9920f8128717c710b6b3" title=" " alt="" coords="258,223,369,250"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="715,136,868,177"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="481,5,655,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="487,71,649,112"/>
</map>
</div>

</div>
</div>
<a id="a2686dd54e6d39c86d0321bd617b115d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2686dd54e6d39c86d0321bd617b115d4">&#9670;&nbsp;</a></span>continue_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::continue_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b" title="检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue.">step_over()</a>_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a2686dd54e6d39c86d0321bd617b115d4_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a2686dd54e6d39c86d0321bd617b115d4_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a2686dd54e6d39c86d0321bd617b115d4_cgraph" id="classminidbg_1_1debugger_a2686dd54e6d39c86d0321bd617b115d4_cgraph">
<area shape="rect" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="5,35,157,76"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="205,5,368,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="416,64,568,105"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="816,35,968,76"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1016,35,1177,76"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="616,64,768,105"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="616,129,768,171"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="816,129,968,171"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1017,129,1177,171"/>
</map>
</div>

</div>
</div>
<a id="adddaa3f5b34d13a5c22b49ebb6ec58e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddaa3f5b34d13a5c22b49ebb6ec58e4">&#9670;&nbsp;</a></span>dump_registers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::dump_registers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>打印目标进程的寄存器信息 <br  />
 </p>
<p>遍历寄存器描述符数组，通过 get_register_value 函数获取每个寄存器的值，并打印出来 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_adddaa3f5b34d13a5c22b49ebb6ec58e4_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_adddaa3f5b34d13a5c22b49ebb6ec58e4_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_adddaa3f5b34d13a5c22b49ebb6ec58e4_cgraph" id="classminidbg_1_1debugger_adddaa3f5b34d13a5c22b49ebb6ec58e4_cgraph">
<area shape="rect" title="打印目标进程的寄存器信息" alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="205,5,367,47"/>
</map>
</div>

</div>
</div>
<a id="a9075df44cb4df2729c1036c035b0c85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9075df44cb4df2729c1036c035b0c85c">&#9670;&nbsp;</a></span>finish_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::finish_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a9075df44cb4df2729c1036c035b0c85c_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a9075df44cb4df2729c1036c035b0c85c_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a9075df44cb4df2729c1036c035b0c85c_cgraph" id="classminidbg_1_1debugger_a9075df44cb4df2729c1036c035b0c85c_cgraph">
<area shape="rect" title=" " alt="" coords="5,116,157,158"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a16c19e64daba632bf0807d58bff713f7" title="跳出函数：从rbp获取返回地址，检查是否有断点，无则设置，然后continue；如刚设置了断点，则去除，如原有则不动。" alt="" coords="205,116,357,158"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="428,51,580,92"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1461,22,1623,63"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff" title=" " alt="" coords="428,116,580,158"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128" title="移除地址addr上的断点。" alt="" coords="428,182,580,223"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="405,247,603,288"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="651,51,813,92"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="861,110,1013,151"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1261,51,1413,92"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="1061,110,1213,151"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="1061,175,1213,216"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1261,175,1413,216"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1462,175,1622,216"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="655,247,809,288"/>
</map>
</div>

</div>
</div>
<a id="a5c019420f24ef96e95a145b3a62c5973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c019420f24ef96e95a145b3a62c5973">&#9670;&nbsp;</a></span>get_backtrace_vct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;uint64_t, std::string&gt; &gt; minidbg::debugger::get_backtrace_vct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前线程的函数调用链回溯信息息。 </p>
<dl class="section return"><dt>返回</dt><dd>std::vector&lt;std::pair&lt;uint64_t, std::string&gt;&gt; 包含调用堆栈信息的向量，每个元素为函数起始地址和函数名的键值对 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a5c019420f24ef96e95a145b3a62c5973_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a5c019420f24ef96e95a145b3a62c5973_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a5c019420f24ef96e95a145b3a62c5973_cgraph" id="classminidbg_1_1debugger_a5c019420f24ef96e95a145b3a62c5973_cgraph">
<area shape="rect" title="获取当前线程的函数调用链回溯信息息。" alt="" coords="5,100,157,141"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a1f8a4061ffd8420395b9d8a83358567a" title="确定当前指令所属的函数" alt="" coords="205,5,368,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="211,71,363,112"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="416,100,577,141"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff" title=" " alt="" coords="211,188,363,229"/>
</map>
</div>

</div>
</div>
<a id="a1f8a4061ffd8420395b9d8a83358567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8a4061ffd8420395b9d8a83358567a">&#9670;&nbsp;</a></span>get_function_from_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structminidbg_1_1asm__head.html">asm_head</a> minidbg::debugger::get_function_from_pc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>确定当前指令所属的函数 </p>

</div>
</div>
<a id="a622b0db8714bdea3a20003d0a0fc3cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622b0db8714bdea3a20003d0a0fc3cb6">&#9670;&nbsp;</a></span>get_global_stack_vct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;uint64_t, std::vector&lt;uint8_t&gt; &gt; &gt; minidbg::debugger::get_global_stack_vct </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>end_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取全局堆栈信息。 </p>
<p>从指定的起始地址开始，以8字节为单位遍历内存区域，读取每个地址处的数据，将其转换为字节向量存储起来。 最后返回包含这些信息的向量，每个元素是一个地址和对应的字节向量。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_addr</td><td>起始地址（包含） </td></tr>
    <tr><td class="paramname">end_addr</td><td>终止地址（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::vector&lt;std::pair&lt;uint64_t, std::vector&lt;uint8_t&gt;&gt;&gt; 包含全局堆栈信息的向量，每个元素为一个地址和对应的字节向量 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a622b0db8714bdea3a20003d0a0fc3cb6_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a622b0db8714bdea3a20003d0a0fc3cb6_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a622b0db8714bdea3a20003d0a0fc3cb6_cgraph" id="classminidbg_1_1debugger_a622b0db8714bdea3a20003d0a0fc3cb6_cgraph">
<area shape="rect" title="获取全局堆栈信息。" alt="" coords="5,5,164,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff" title=" " alt="" coords="212,5,364,47"/>
</map>
</div>

</div>
</div>
<a id="ab0a72f56b837540af184db2c53de4aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a72f56b837540af184db2c53de4aef">&#9670;&nbsp;</a></span>get_line_entry_from_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dwarf::line_table::iterator minidbg::debugger::get_line_entry_from_pc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the line entry from pc object </p>
<dl class="section return"><dt>返回</dt><dd>返回源代码行的迭代器，如找不到源码，将抛出异常。常见于程序执行完毕、进入系统调用和库函数。 </dd></dl>

</div>
</div>
<a id="a5317fd19f40e33920e7235bb4406b460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5317fd19f40e33920e7235bb4406b460">&#9670;&nbsp;</a></span>get_next_line_entry_from_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dwarf::line_table::iterator minidbg::debugger::get_next_line_entry_from_pc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据程序计数器获取下一行的DWARF调试信息。 </p>
<p>根据给定的程序计数器（PC），获取下一行的DWARF调试信息，并返回迭代器指向该行。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc</td><td>程序计数器 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>dwarf::line_table::iterator 指向下一行的迭代器</dd></dl>
<p>该函数通过调用get_line_entry_from_pc函数获取当前PC对应的行的调试信息， 然后通过递增迭代器实现获取下一行的调试信息，最后返回指向下一行的迭代器。 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a5317fd19f40e33920e7235bb4406b460_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a5317fd19f40e33920e7235bb4406b460_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a5317fd19f40e33920e7235bb4406b460_cgraph" id="classminidbg_1_1debugger_a5317fd19f40e33920e7235bb4406b460_cgraph">
<area shape="rect" title="根据程序计数器获取下一行的DWARF调试信息。" alt="" coords="5,5,157,61"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="205,13,380,54"/>
</map>
</div>

</div>
</div>
<a id="a56e26f0c99ba1bd0390cf2dba4e24a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e26f0c99ba1bd0390cf2dba4e24a29">&#9670;&nbsp;</a></span>get_offset_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::get_offset_pc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a56e26f0c99ba1bd0390cf2dba4e24a29_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a56e26f0c99ba1bd0390cf2dba4e24a29_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a56e26f0c99ba1bd0390cf2dba4e24a29_cgraph" id="classminidbg_1_1debugger_a56e26f0c99ba1bd0390cf2dba4e24a29_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="205,5,357,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="205,71,357,112"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="405,5,567,47"/>
</map>
</div>

</div>
</div>
<a id="a782a179d08d545c03c989f54f7aa3127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782a179d08d545c03c989f54f7aa3127">&#9670;&nbsp;</a></span>get_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::get_pc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前程序计数器（PC）的值。 </p>
<dl class="section return"><dt>返回</dt><dd>uint64_t 当前程序计数器（PC）的值 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a782a179d08d545c03c989f54f7aa3127_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a782a179d08d545c03c989f54f7aa3127_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a782a179d08d545c03c989f54f7aa3127_cgraph" id="classminidbg_1_1debugger_a782a179d08d545c03c989f54f7aa3127_cgraph">
<area shape="rect" title="获取当前程序计数器（PC）的值。" alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="205,5,367,47"/>
</map>
</div>

</div>
</div>
<a id="ad91741cf22396213a7f23dfa440d52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91741cf22396213a7f23dfa440d52a6">&#9670;&nbsp;</a></span>get_ram_vct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, u_int64_t&gt; &gt; minidbg::debugger::get_ram_vct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取程序中各个寄存器的值。 </p>
<dl class="section return"><dt>返回</dt><dd>std::vector&lt;std::pair&lt;std::string, u_int64_t&gt;&gt; 包含寄存器名称和值的向量 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ad91741cf22396213a7f23dfa440d52a6_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ad91741cf22396213a7f23dfa440d52a6_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ad91741cf22396213a7f23dfa440d52a6_cgraph" id="classminidbg_1_1debugger_ad91741cf22396213a7f23dfa440d52a6_cgraph">
<area shape="rect" title="获取程序中各个寄存器的值。" alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="205,5,367,47"/>
</map>
</div>

</div>
</div>
<a id="abbf1ba35f894fac6403185e0acdd4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1ba35f894fac6403185e0acdd4536">&#9670;&nbsp;</a></span>get_rbp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::get_rbp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前基址寄存器（RBP）的值。 </p>
<dl class="section return"><dt>返回</dt><dd>uint64_t 当前基址寄存器（RBP）的值 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_abbf1ba35f894fac6403185e0acdd4536_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_abbf1ba35f894fac6403185e0acdd4536_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_abbf1ba35f894fac6403185e0acdd4536_cgraph" id="classminidbg_1_1debugger_abbf1ba35f894fac6403185e0acdd4536_cgraph">
<area shape="rect" title="获取当前基址寄存器（RBP）的值。" alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="205,5,367,47"/>
</map>
</div>

</div>
</div>
<a id="a7326411326dc7be2ca1780747b73c668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7326411326dc7be2ca1780747b73c668">&#9670;&nbsp;</a></span>get_rsp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::get_rsp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前栈指针寄存器（RSP）的值。 </p>
<dl class="section return"><dt>返回</dt><dd>uint64_t 当前栈指针寄存器（RSP）的值 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a7326411326dc7be2ca1780747b73c668_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a7326411326dc7be2ca1780747b73c668_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a7326411326dc7be2ca1780747b73c668_cgraph" id="classminidbg_1_1debugger_a7326411326dc7be2ca1780747b73c668_cgraph">
<area shape="rect" title="获取当前栈指针寄存器（RSP）的值。" alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="205,5,367,47"/>
</map>
</div>

</div>
</div>
<a id="a4875fc7f36cb21d20c02bc0778f986d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4875fc7f36cb21d20c02bc0778f986d5">&#9670;&nbsp;</a></span>get_signal_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">siginfo_t minidbg::debugger::get_signal_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the signal info </p>
<dl class="section return"><dt>返回</dt><dd>siginfo_t </dd></dl>

</div>
</div>
<a id="a8d63db538666ebb38ea899d1821a370b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d63db538666ebb38ea899d1821a370b">&#9670;&nbsp;</a></span>get_src_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned minidbg::debugger::get_src_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前源代码行号。 </p>
<dl class="section return"><dt>返回</dt><dd>unsigned 当前源代码行号 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a8d63db538666ebb38ea899d1821a370b_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a8d63db538666ebb38ea899d1821a370b_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a8d63db538666ebb38ea899d1821a370b_cgraph" id="classminidbg_1_1debugger_a8d63db538666ebb38ea899d1821a370b_cgraph">
<area shape="rect" title="获取当前源代码行号。" alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="205,5,380,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="217,71,369,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="428,37,580,79"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="428,103,580,144"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="628,37,789,79"/>
</map>
</div>

</div>
</div>
<a id="ab5128ad097ff8fdb0cdb5bf17b979a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5128ad097ff8fdb0cdb5bf17b979a58">&#9670;&nbsp;</a></span>handle_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::handle_command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理用户输入的调试器命令，并执行相应操作 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>用户输入的命令字符串</td></tr>
  </table>
  </dd>
</dl>
<p>根据命令的前缀进行分类处理，具体逻辑如下：</p>
<ul>
<li>如果命令以 "break" 开头，则处理设置断点的逻辑。</li>
<li>如果命令以 "register" 开头，则根据子命令执行相关的寄存器操作，包括查看寄存器内容、修改寄存器值等。</li>
<li>如果命令以 "symbol" 开头，则查找并打印符号信息。</li>
<li>如果命令以 "memory" 开头，则根据子命令执行内存读写操作。</li>
<li>如果命令以 "si" 开头，则执行单步指令，并检查是否有断点。</li>
<li>如果命令以 "step" 开头，则执行单步进入操作。</li>
<li>如果命令以 "next" 开头，则执行下一步操作。</li>
<li>如果命令以 "finish" 开头，则执行执行到函数返回操作。</li>
<li>如果命令以 "backtrace" 开头，则打印回溯信息。</li>
<li>如果命令以 "ls" 开头，则打印源代码和汇编信息。</li>
<li>其他情况下，输出错误信息。 </li>
</ul>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ab5128ad097ff8fdb0cdb5bf17b979a58_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ab5128ad097ff8fdb0cdb5bf17b979a58_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ab5128ad097ff8fdb0cdb5bf17b979a58_cgraph" id="classminidbg_1_1debugger_ab5128ad097ff8fdb0cdb5bf17b979a58_cgraph">
<area shape="rect" title="处理用户输入的调试器命令，并执行相应操作" alt="" coords="5,573,157,615"/>
<area shape="rect" href="classminidbg_1_1debugger.html#adddaa3f5b34d13a5c22b49ebb6ec58e4" title="打印目标进程的寄存器信息" alt="" coords="951,883,1103,924"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1551,824,1712,865"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="728,387,903,428"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="499,113,651,155"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1351,308,1503,349"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="739,85,891,127"/>
<area shape="rect" href="namespaceminidbg.html#a40ee5a3032ff64e74bbc60f507ee61e6" title="根据给定的寄存器名称字符串，获取对应的寄存器枚举变量。" alt="" coords="233,340,394,381"/>
<area shape="rect" href="namespaceminidbg.html#abb5c65a7eb3c93593b5da8fbd6905385" title="判断字符串s是否为字符串of的前缀。" alt="" coords="244,406,383,433"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a268b73756c673c5a34cf25030bff03a1" title="查找符号, handle_command() 中使用." alt="" coords="237,275,389,316"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff" title=" " alt="" coords="499,857,651,899"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="476,609,673,651"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ad4e95fd23fd5391089f97a198c04c8b5" title="Set the breakpoint at function object" alt="" coords="214,508,413,549"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a3953940c630495e035444371643727aa" title="通过&#39;file:line&#39;形式的命令设置断点。" alt="" coords="205,573,421,615"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1551,940,1711,981"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76" title="让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()" alt="" coords="485,179,664,235"/>
<area shape="rect" href="namespaceminidbg.html#a53e4cc1dcf1b9920f8128717c710b6b3" title=" " alt="" coords="258,873,369,899"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a36f22ffa07e4cf1d70480573c2075328" title="单步进入/进入到下一个源代码行: 循环执行单条指令，源代码行号发生变化，循环结束" alt="" coords="237,209,389,251"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a16c19e64daba632bf0807d58bff713f7" title="跳出函数：从rbp获取返回地址，检查是否有断点，无则设置，然后continue；如刚设置了断点，则去除，如原有则不动。" alt="" coords="237,756,389,797"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b" title="检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue." alt="" coords="237,639,389,680"/>
<area shape="rect" href="namespacesymboltype.html#a9bd44f3f011af37e528a03f3584f1dd7" title="将 enum symbol_type 类型转换为字符串" alt="" coords="231,1075,395,1102"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a8111b5ed151d51b9e0a8480a0a845286" title=" " alt="" coords="237,1127,389,1168"/>
<area shape="rect" href="namespacesymboltype.html#a92af0a7d66c478a7baef4d31867b6c72" title="将elf++库中的符号类型转换为 enum symbol_type" alt="" coords="469,310,680,337"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="739,492,892,533"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="494,463,655,504"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="729,293,901,335"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="734,557,897,599"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="951,557,1103,599"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="1151,525,1303,567"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="1151,591,1303,632"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1351,908,1503,949"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="499,675,651,716"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128" title="移除地址addr上的断点。" alt="" coords="499,740,651,781"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5317fd19f40e33920e7235bb4406b460" title="根据程序计数器获取下一行的DWARF调试信息。" alt="" coords="499,529,651,585"/>
</map>
</div>

</div>
</div>
<a id="a5679e71844ee8af9206377b3f9d61f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5679e71844ee8af9206377b3f9d61f82">&#9670;&nbsp;</a></span>handle_sigtrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::handle_sigtrap </td>
          <td>(</td>
          <td class="paramtype">siginfo_t&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理： <br  />
 </p>
<p>如果si_code为SI_KERNEL或TRAP_BRKPT，表示到了断点处，获取当前指令地址（nowpc）然后将指令地址减1，程序停留在断点处的前一条指令上。 <br  />
 接着，将当前指令地址转换为加载地址（偏移量），并通过该地址获取对应的源代码行信息。最后，可以根据需要打印源代码行信息或进行其他操作。 如果si_code为TRAP_TRACE，表示程序进入了跟踪状态，通常不需要额外处理，因此只是简单地打印一条信息。 如果si_code不是上述两种情况，则打印一条未知SIGTRAP代码的消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>根据 SIGTRAP 信号信息执行不同的操作，包括触发断点、打印调试信息等。</p>
<p>该函数根据接收到的信号信息执行不同的操作：</p><ul>
<li>如果信号代码为SI_KERNEL或TRAP_BRKPT，则表示触发了断点，将当前程序计数器减一，并打印断点信息。</li>
<li>如果信号代码为TRAP_TRACE，则表示接收到了追踪信号。</li>
<li>对于其他信号代码，打印出未知的信号代码信息。</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>信号信息 </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a5679e71844ee8af9206377b3f9d61f82_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a5679e71844ee8af9206377b3f9d61f82_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a5679e71844ee8af9206377b3f9d61f82_cgraph" id="classminidbg_1_1debugger_a5679e71844ee8af9206377b3f9d61f82_cgraph">
<area shape="rect" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="205,5,357,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="205,71,357,112"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="405,5,567,47"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="406,71,566,112"/>
</map>
</div>

</div>
</div>
<a id="a644b99a4260aa9c5373a1c0b375cf9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b99a4260aa9c5373a1c0b375cf9c5">&#9670;&nbsp;</a></span>initDbg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::initDbg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prog_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化mini调试器。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog_name</td><td>目标程序的名称。 </td></tr>
    <tr><td class="paramname">pid</td><td>目标程序的进程ID。 </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a644b99a4260aa9c5373a1c0b375cf9c5_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a644b99a4260aa9c5373a1c0b375cf9c5_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a644b99a4260aa9c5373a1c0b375cf9c5_cgraph" id="classminidbg_1_1debugger_a644b99a4260aa9c5373a1c0b375cf9c5_cgraph">
<area shape="rect" title="初始化mini调试器。" alt="" coords="5,136,157,177"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aa16b14e2a5c30f85a19b60dfed2436ee" title="初始化" alt="" coords="205,5,376,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a6d445a16899ac9ced43f17bc61e5ce20" title="加载汇编数据到m_asm_vct向量中" alt="" coords="215,71,367,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a859bd0fa6bf7b2981ca554be9d13505b" title="逐行读取源码到m_src_vct向量中" alt="" coords="215,136,367,177"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a61dff0e30d6837427da037845dca7516" title="使用 objdump 命令生成反汇编代码" alt="" coords="205,201,376,243"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="215,267,367,308"/>
<area shape="rect" href="namespacesymboltype.html#a9bd44f3f011af37e528a03f3584f1dd7" title="将 enum symbol_type 类型转换为字符串" alt="" coords="424,13,588,39"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a570ad5713f2f54e9472ea6edb857bc3a" title=" " alt="" coords="426,71,586,112"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a64ce750db87bae204f7409d6d4b6b513" title=" " alt="" coords="636,85,796,127"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a3d3b427fe29386e5a676f83f7ab663d7" title=" " alt="" coords="636,20,796,61"/>
<area shape="rect" href="namespaceminidbg.html#a53e4cc1dcf1b9920f8128717c710b6b3" title=" " alt="" coords="869,29,980,55"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a0b9666545bf212807f06451c6a1e4b85" title=" " alt="" coords="845,83,1005,124"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#acedec0c591a904b95de46ebff22dd27c" title=" " alt="" coords="845,148,1005,189"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="640,243,792,284"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="430,191,582,232"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="844,243,1005,284"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="430,256,582,297"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="430,321,582,363"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="640,321,792,363"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="845,321,1005,363"/>
</map>
</div>

</div>
</div>
<a id="aa16b14e2a5c30f85a19b60dfed2436ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16b14e2a5c30f85a19b60dfed2436ee">&#9670;&nbsp;</a></span>initialise_load_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::initialise_load_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化 </p>
<p>获取程序的偏移量</p>
<p>首先，通过m_elf.get_hdr().type获取目标程序的 ELF 文件类型。 如果是动态链接库（et::dyn），则需要通过其他方式获取加载地址。 /proc/&lt;pid&gt;/maps是一个特殊的 Linux 文件，用于列出进程的内存映射。 从maps文件中读取第一行，这一行包含了动态库的内存映射范围，形如&lt;start_addr&gt;-&lt;end_addr&gt;。 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_aa16b14e2a5c30f85a19b60dfed2436ee_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_aa16b14e2a5c30f85a19b60dfed2436ee_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_aa16b14e2a5c30f85a19b60dfed2436ee_cgraph" id="classminidbg_1_1debugger_aa16b14e2a5c30f85a19b60dfed2436ee_cgraph">
<area shape="rect" title="初始化" alt="" coords="5,5,176,47"/>
<area shape="rect" href="namespacesymboltype.html#a9bd44f3f011af37e528a03f3584f1dd7" title="将 enum symbol_type 类型转换为字符串" alt="" coords="224,13,388,39"/>
</map>
</div>

</div>
</div>
<a id="a6d445a16899ac9ced43f17bc61e5ce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d445a16899ac9ced43f17bc61e5ce20">&#9670;&nbsp;</a></span>initialise_load_asm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::initialise_load_asm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>加载汇编数据到m_asm_vct向量中 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a6d445a16899ac9ced43f17bc61e5ce20_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a6d445a16899ac9ced43f17bc61e5ce20_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a6d445a16899ac9ced43f17bc61e5ce20_cgraph" id="classminidbg_1_1debugger_a6d445a16899ac9ced43f17bc61e5ce20_cgraph">
<area shape="rect" title="加载汇编数据到m_asm_vct向量中" alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a570ad5713f2f54e9472ea6edb857bc3a" title=" " alt="" coords="205,39,365,80"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a64ce750db87bae204f7409d6d4b6b513" title=" " alt="" coords="413,71,573,112"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a3d3b427fe29386e5a676f83f7ab663d7" title=" " alt="" coords="413,5,573,47"/>
<area shape="rect" href="namespaceminidbg.html#a53e4cc1dcf1b9920f8128717c710b6b3" title=" " alt="" coords="646,14,757,41"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#a0b9666545bf212807f06451c6a1e4b85" title=" " alt="" coords="621,68,781,109"/>
<area shape="rect" href="classminidbg_1_1asmparaser.html#acedec0c591a904b95de46ebff22dd27c" title=" " alt="" coords="621,133,781,175"/>
</map>
</div>

</div>
</div>
<a id="a859bd0fa6bf7b2981ca554be9d13505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859bd0fa6bf7b2981ca554be9d13505b">&#9670;&nbsp;</a></span>initialise_load_src()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::initialise_load_src </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>逐行读取源码到m_src_vct向量中 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a859bd0fa6bf7b2981ca554be9d13505b_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a859bd0fa6bf7b2981ca554be9d13505b_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a859bd0fa6bf7b2981ca554be9d13505b_cgraph" id="classminidbg_1_1debugger_a859bd0fa6bf7b2981ca554be9d13505b_cgraph">
<area shape="rect" title="逐行读取源码到m_src_vct向量中" alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="205,5,357,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="205,71,357,112"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="405,5,567,47"/>
</map>
</div>

</div>
</div>
<a id="a61dff0e30d6837427da037845dca7516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dff0e30d6837427da037845dca7516">&#9670;&nbsp;</a></span>initialise_run_objdump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::initialise_run_objdump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>使用 objdump 命令生成反汇编代码 </p>

</div>
</div>
<a id="a634ab39fc9fbfa7c213629aaa9b0a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634ab39fc9fbfa7c213629aaa9b0a9eb">&#9670;&nbsp;</a></span>kill_prog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool minidbg::debugger::kill_prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>终止被调试程序 </p>

</div>
</div>
<a id="a268b73756c673c5a34cf25030bff03a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268b73756c673c5a34cf25030bff03a1">&#9670;&nbsp;</a></span>lookup_symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structsymboltype_1_1symbol.html">symboltype::symbol</a>&gt; minidbg::debugger::lookup_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>查找符号, <a class="el" href="classminidbg_1_1debugger.html#ab5128ad097ff8fdb0cdb5bf17b979a58" title="处理用户输入的调试器命令，并执行相应操作">handle_command()</a> 中使用. </p>
<p>根据给定的符号名称，查找ELF文件中对应的符号，并返回包含所有匹配符号的向量。</p>
<p>该函数遍历ELF文件的所有节，检查类型为符号表（symtab）或动态符号表（dynsym）的节。 对于每个符号，如果名称与给定的名称匹配，则将符号生成 symbol 结构体添加到结果向量中。 最后，使用std::unique函数去除重复的符号，并返回结果向量。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>符号名称 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::vector&lt;symboltype::symbol&gt; 包含所有匹配符号的向量 </dd></dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a268b73756c673c5a34cf25030bff03a1_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a268b73756c673c5a34cf25030bff03a1_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a268b73756c673c5a34cf25030bff03a1_cgraph" id="classminidbg_1_1debugger_a268b73756c673c5a34cf25030bff03a1_cgraph">
<area shape="rect" title="查找符号, handle_command() 中使用." alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespacesymboltype.html#a92af0a7d66c478a7baef4d31867b6c72" title="将elf++库中的符号类型转换为 enum symbol_type" alt="" coords="205,13,416,39"/>
</map>
</div>

</div>
</div>
<a id="aa06d1327a1c6b32427035bee28cc83dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06d1327a1c6b32427035bee28cc83dd">&#9670;&nbsp;</a></span>next_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::next_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_aa06d1327a1c6b32427035bee28cc83dd_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_aa06d1327a1c6b32427035bee28cc83dd_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_aa06d1327a1c6b32427035bee28cc83dd_cgraph" id="classminidbg_1_1debugger_aa06d1327a1c6b32427035bee28cc83dd_cgraph">
<area shape="rect" title=" " alt="" coords="5,298,157,340"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aa08ae391b77f28a593e435516dc2f50b" title="检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue." alt="" coords="205,298,357,340"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="428,82,580,124"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5317fd19f40e33920e7235bb4406b460" title="根据程序计数器获取下一行的DWARF调试信息。" alt="" coords="428,254,580,310"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="428,188,580,229"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="423,334,585,376"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128" title="移除地址addr上的断点。" alt="" coords="428,400,580,441"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="405,465,603,506"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="657,24,819,65"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="873,68,1025,109"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1273,72,1425,113"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1473,72,1635,113"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="1073,38,1225,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="1073,104,1225,145"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1273,137,1425,178"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1474,137,1634,178"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="651,286,825,328"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="662,221,814,262"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="661,465,815,506"/>
</map>
</div>

</div>
</div>
<a id="aadec3114b66ec64774be46873a97e307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadec3114b66ec64774be46873a97e307">&#9670;&nbsp;</a></span>offset_dwarf_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::offset_dwarf_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将相对地址转换为实际地址 </p>

</div>
</div>
<a id="ace071934f7fedb171618a830e0b2f856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace071934f7fedb171618a830e0b2f856">&#9670;&nbsp;</a></span>offset_load_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::offset_load_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从实际地址转换为相对地址 </p>

</div>
</div>
<a id="aabde5dd3945efd3cffdec4e6cd245cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabde5dd3945efd3cffdec4e6cd245cff">&#9670;&nbsp;</a></span>read_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::read_memory </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57cd3a2d4d8a89d1c61e516f0d0db128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cd3a2d4d8a89d1c61e516f0d0db128">&#9670;&nbsp;</a></span>remove_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::remove_breakpoint </td>
          <td>(</td>
          <td class="paramtype">std::intptr_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除地址addr上的断点。 </p>

</div>
</div>
<a id="a33de60b0cf721c1fd24e5a3b5159e205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de60b0cf721c1fd24e5a3b5159e205">&#9670;&nbsp;</a></span>set_breakpoint_at_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::set_breakpoint_at_address </td>
          <td>(</td>
          <td class="paramtype">std::intptr_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set breakpoint by address </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a33de60b0cf721c1fd24e5a3b5159e205_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a33de60b0cf721c1fd24e5a3b5159e205_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a33de60b0cf721c1fd24e5a3b5159e205_cgraph" id="classminidbg_1_1debugger_a33de60b0cf721c1fd24e5a3b5159e205_cgraph">
<area shape="rect" title="Set breakpoint by address" alt="" coords="5,5,203,47"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="251,5,404,47"/>
</map>
</div>

</div>
</div>
<a id="ad4e95fd23fd5391089f97a198c04c8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e95fd23fd5391089f97a198c04c8b5">&#9670;&nbsp;</a></span>set_breakpoint_at_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::set_breakpoint_at_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the breakpoint at function object </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ad4e95fd23fd5391089f97a198c04c8b5_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ad4e95fd23fd5391089f97a198c04c8b5_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ad4e95fd23fd5391089f97a198c04c8b5_cgraph" id="classminidbg_1_1debugger_ad4e95fd23fd5391089f97a198c04c8b5_cgraph">
<area shape="rect" title="Set the breakpoint at function object" alt="" coords="5,71,204,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="263,5,438,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="270,71,431,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="252,136,449,177"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="497,136,651,177"/>
</map>
</div>

</div>
</div>
<a id="a3953940c630495e035444371643727aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3953940c630495e035444371643727aa">&#9670;&nbsp;</a></span>set_breakpoint_at_source_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::set_breakpoint_at_source_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>通过'<a href="file:line'">file:line'</a>形式的命令设置断点。 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td></td></tr>
    <tr><td class="paramname">line</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a3953940c630495e035444371643727aa_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a3953940c630495e035444371643727aa_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a3953940c630495e035444371643727aa_cgraph" id="classminidbg_1_1debugger_a3953940c630495e035444371643727aa_cgraph">
<area shape="rect" title="通过&#39;file:line&#39;形式的命令设置断点。" alt="" coords="5,39,221,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="287,5,449,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="269,71,467,112"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="515,71,668,112"/>
</map>
</div>

</div>
</div>
<a id="ab6efac5e854a13f0bc1e6a07a8a208d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6efac5e854a13f0bc1e6a07a8a208d2">&#9670;&nbsp;</a></span>set_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::set_pc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ab6efac5e854a13f0bc1e6a07a8a208d2_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ab6efac5e854a13f0bc1e6a07a8a208d2_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ab6efac5e854a13f0bc1e6a07a8a208d2_cgraph" id="classminidbg_1_1debugger_ab6efac5e854a13f0bc1e6a07a8a208d2_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="205,5,365,47"/>
</map>
</div>

</div>
</div>
<a id="aaff1e34730485fa0ac3900fb8c88d448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff1e34730485fa0ac3900fb8c88d448">&#9670;&nbsp;</a></span>si_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::si_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_aaff1e34730485fa0ac3900fb8c88d448_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_aaff1e34730485fa0ac3900fb8c88d448_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_aaff1e34730485fa0ac3900fb8c88d448_cgraph" id="classminidbg_1_1debugger_aaff1e34730485fa0ac3900fb8c88d448_cgraph">
<area shape="rect" title=" " alt="" coords="5,23,157,64"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76" title="让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()" alt="" coords="205,15,384,71"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1052,19,1204,60"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="432,88,604,129"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="437,23,599,64"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1252,19,1413,60"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="652,83,804,124"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="852,77,1004,119"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="852,143,1004,184"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1052,143,1204,184"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1253,143,1413,184"/>
</map>
</div>

</div>
</div>
<a id="ae9ff213c04734e537744be8a3e915345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ff213c04734e537744be8a3e915345">&#9670;&nbsp;</a></span>single_step_instruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::single_step_instruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>向子进程发送信号，让子进程只执行一条指令 </p>
<p>不进行断点检查，直接认为没有断点。 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ae9ff213c04734e537744be8a3e915345_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ae9ff213c04734e537744be8a3e915345_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ae9ff213c04734e537744be8a3e915345_cgraph" id="classminidbg_1_1debugger_ae9ff213c04734e537744be8a3e915345_cgraph">
<area shape="rect" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="5,39,177,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="225,39,377,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="425,5,577,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="425,71,577,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="625,37,777,79"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="625,103,777,144"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="825,37,987,79"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="826,103,986,144"/>
</map>
</div>

</div>
</div>
<a id="a60c395083ae6156ababe81561ab17a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c395083ae6156ababe81561ab17a76">&#9670;&nbsp;</a></span>single_step_instruction_with_breakpoint_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::single_step_instruction_with_breakpoint_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step() </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a60c395083ae6156ababe81561ab17a76_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a60c395083ae6156ababe81561ab17a76_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a60c395083ae6156ababe81561ab17a76_cgraph" id="classminidbg_1_1debugger_a60c395083ae6156ababe81561ab17a76_cgraph">
<area shape="rect" title="让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()" alt="" coords="5,15,184,71"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="852,19,1004,60"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="232,88,404,129"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="237,23,399,64"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1052,19,1213,60"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="452,83,604,124"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="652,77,804,119"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="652,143,804,184"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="852,143,1004,184"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1053,143,1213,184"/>
</map>
</div>

</div>
</div>
<a id="a36f22ffa07e4cf1d70480573c2075328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f22ffa07e4cf1d70480573c2075328">&#9670;&nbsp;</a></span>step_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::step_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>单步进入/进入到下一个源代码行: 循环执行单条指令，源代码行号发生变化，循环结束 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a36f22ffa07e4cf1d70480573c2075328_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a36f22ffa07e4cf1d70480573c2075328_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a36f22ffa07e4cf1d70480573c2075328_cgraph" id="classminidbg_1_1debugger_a36f22ffa07e4cf1d70480573c2075328_cgraph">
<area shape="rect" title="单步进入/进入到下一个源代码行: 循环执行单条指令，源代码行号发生变化，循环结束" alt="" coords="5,140,157,181"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="207,67,382,108"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="219,231,371,272"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76" title="让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()" alt="" coords="205,133,384,189"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1052,155,1204,196"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="442,289,594,331"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1252,155,1413,196"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="432,56,604,97"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="437,121,599,163"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="652,64,804,105"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="852,71,1004,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="852,5,1004,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1052,5,1204,47"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1253,5,1413,47"/>
</map>
</div>

</div>
</div>
<a id="acb73e8080bbd2fa305b8d383b4ddd3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb73e8080bbd2fa305b8d383b4ddd3e4">&#9670;&nbsp;</a></span>step_into_execution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::step_into_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_acb73e8080bbd2fa305b8d383b4ddd3e4_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_acb73e8080bbd2fa305b8d383b4ddd3e4_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_acb73e8080bbd2fa305b8d383b4ddd3e4_cgraph" id="classminidbg_1_1debugger_acb73e8080bbd2fa305b8d383b4ddd3e4_cgraph">
<area shape="rect" title=" " alt="" coords="5,140,157,181"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a36f22ffa07e4cf1d70480573c2075328" title="单步进入/进入到下一个源代码行: 循环执行单条指令，源代码行号发生变化，循环结束" alt="" coords="205,140,357,181"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="407,67,582,108"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="419,231,571,272"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a60c395083ae6156ababe81561ab17a76" title="让子进程执行一条指令。根据当前指令是否有断点，分别调用step_over_breakpoint()和single_step()" alt="" coords="405,133,584,189"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1252,155,1404,196"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="642,289,794,331"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1452,155,1613,196"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ae9ff213c04734e537744be8a3e915345" title="向子进程发送信号，让子进程只执行一条指令" alt="" coords="632,56,804,97"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="637,121,799,163"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="852,64,1004,105"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="1052,71,1204,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="1052,5,1204,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1252,5,1404,47"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1453,5,1613,47"/>
</map>
</div>

</div>
</div>
<a id="a16c19e64daba632bf0807d58bff713f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c19e64daba632bf0807d58bff713f7">&#9670;&nbsp;</a></span>step_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::step_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>跳出函数：从rbp获取返回地址，检查是否有断点，无则设置，然后continue；如刚设置了断点，则去除，如原有则不动。 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_a16c19e64daba632bf0807d58bff713f7_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_a16c19e64daba632bf0807d58bff713f7_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_a16c19e64daba632bf0807d58bff713f7_cgraph" id="classminidbg_1_1debugger_a16c19e64daba632bf0807d58bff713f7_cgraph">
<area shape="rect" title="跳出函数：从rbp获取返回地址，检查是否有断点，无则设置，然后continue；如刚设置了断点，则去除，如原有则不动。" alt="" coords="5,116,157,158"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="228,51,380,92"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1261,22,1423,63"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aabde5dd3945efd3cffdec4e6cd245cff" title=" " alt="" coords="228,116,380,158"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128" title="移除地址addr上的断点。" alt="" coords="228,182,380,223"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="205,247,403,288"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="451,51,613,92"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="661,110,813,151"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1061,51,1213,92"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="861,110,1013,151"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="861,175,1013,216"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1061,175,1213,216"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1262,175,1422,216"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="455,247,609,288"/>
</map>
</div>

</div>
</div>
<a id="aa08ae391b77f28a593e435516dc2f50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ae391b77f28a593e435516dc2f50b">&#9670;&nbsp;</a></span>step_over()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::step_over </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_aa08ae391b77f28a593e435516dc2f50b_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_aa08ae391b77f28a593e435516dc2f50b_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_aa08ae391b77f28a593e435516dc2f50b_cgraph" id="classminidbg_1_1debugger_aa08ae391b77f28a593e435516dc2f50b_cgraph">
<area shape="rect" title="检查下一行源码是否设置了断点，如没有则设置，然后continue，再删除；如有则直接continue." alt="" coords="5,298,157,340"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a2686dd54e6d39c86d0321bd617b115d4" title="step_over()_breakpoint()跳过当前断点，然后ptrace_continue，让子进程继续执行" alt="" coords="228,82,380,124"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5317fd19f40e33920e7235bb4406b460" title="根据程序计数器获取下一行的DWARF调试信息。" alt="" coords="228,254,380,310"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a56e26f0c99ba1bd0390cf2dba4e24a29" title=" " alt="" coords="228,188,380,229"/>
<area shape="rect" href="classminidbg_1_1debugger.html#aadec3114b66ec64774be46873a97e307" title="将相对地址转换为实际地址" alt="" coords="223,334,385,376"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a57cd3a2d4d8a89d1c61e516f0d0db128" title="移除地址addr上的断点。" alt="" coords="228,400,380,441"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a33de60b0cf721c1fd24e5a3b5159e205" title="Set breakpoint by address" alt="" coords="205,465,403,506"/>
<area shape="rect" href="classminidbg_1_1debugger.html#acc81497da4da399495135ed332fe01e7" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="457,24,619,65"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="673,68,825,109"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="1073,72,1225,113"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="1273,72,1435,113"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="873,38,1025,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="873,104,1025,145"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="1073,137,1225,178"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="1274,137,1434,178"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab0a72f56b837540af184db2c53de4aef" title="Get the line entry from pc object" alt="" coords="451,286,625,328"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ace071934f7fedb171618a830e0b2f856" title="从实际地址转换为相对地址" alt="" coords="462,221,614,262"/>
<area shape="rect" href="classminidbg_1_1breakpoint.html#a8c4099c042923198070f27bd5c9edcb8" title="启用断点 通过ptrace系统调用读取原始数据，将其最低有效字节（LSB） 替换为软件中断0xcc（用于暂停程序执行）， 然后使用PTRACE_POKEDATA将修改后的数据写入目标地址" alt="" coords="461,465,615,506"/>
</map>
</div>

</div>
</div>
<a id="acc81497da4da399495135ed332fe01e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc81497da4da399495135ed332fe01e7">&#9670;&nbsp;</a></span>step_over_breakpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::step_over_breakpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。 </p>
<p>禁用当前断点, 使用 ptrace_singlestep, 恢复当前断点, 确保在下次执行到该断点时，程序会暂停执行 </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_acc81497da4da399495135ed332fe01e7_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_acc81497da4da399495135ed332fe01e7_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_acc81497da4da399495135ed332fe01e7_cgraph" id="classminidbg_1_1debugger_acc81497da4da399495135ed332fe01e7_cgraph">
<area shape="rect" title="跳过当前断点（执行一条指令），若当前指令没有断点，则不做任何事。" alt="" coords="5,5,168,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="616,5,768,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ade2972e37458f63870e18c34f0a44bc1" title="等待目标进程发送信号并做出相应处理." alt="" coords="216,35,368,76"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="816,5,977,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="416,35,568,76"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="416,100,568,141"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="616,100,768,141"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="817,100,977,141"/>
</map>
</div>

</div>
</div>
<a id="ade2972e37458f63870e18c34f0a44bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2972e37458f63870e18c34f0a44bc1">&#9670;&nbsp;</a></span>wait_for_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::wait_for_signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>等待目标进程发送信号并做出相应处理. </p>
<ul>
<li>如果收到 SIGTRAP 信号，通常表示进程遇到了断点，调用 handle_sigtrap 函数处理。</li>
<li>如果收到 SIGSEGV 信号，表示进程发生了段错误，输出相应信息。 </li>
</ul>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classminidbg_1_1debugger_ade2972e37458f63870e18c34f0a44bc1_cgraph.png" border="0" usemap="#classminidbg_1_1debugger_ade2972e37458f63870e18c34f0a44bc1_cgraph" alt=""/></div>
<map name="classminidbg_1_1debugger_ade2972e37458f63870e18c34f0a44bc1_cgraph" id="classminidbg_1_1debugger_ade2972e37458f63870e18c34f0a44bc1_cgraph">
<area shape="rect" title="等待目标进程发送信号并做出相应处理." alt="" coords="5,39,157,80"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a4875fc7f36cb21d20c02bc0778f986d5" title="Get the signal info" alt="" coords="205,5,357,47"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a5679e71844ee8af9206377b3f9d61f82" title="根据siginfo_t结构体中的si_code字段来判断SIGTRAP信号的具体类型，并进行相应的处理：" alt="" coords="205,71,357,112"/>
<area shape="rect" href="classminidbg_1_1debugger.html#a782a179d08d545c03c989f54f7aa3127" title="获取当前程序计数器（PC）的值。" alt="" coords="405,37,557,79"/>
<area shape="rect" href="classminidbg_1_1debugger.html#ab6efac5e854a13f0bc1e6a07a8a208d2" title=" " alt="" coords="405,103,557,144"/>
<area shape="rect" href="namespaceminidbg.html#aaa5b1886e9ba4a1885c36441d2a7fb2b" title="根据给定的进程ID和寄存器枚举变量，获取该寄存器的值。" alt="" coords="605,37,767,79"/>
<area shape="rect" href="namespaceminidbg.html#a1d7f2dc1f8a79d86673a623564b97cc8" title="设置（改写）指定寄存器的值。" alt="" coords="606,103,766,144"/>
</map>
</div>

</div>
</div>
<a id="a8111b5ed151d51b9e0a8480a0a845286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111b5ed151d51b9e0a8480a0a845286">&#9670;&nbsp;</a></span>write_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void minidbg::debugger::write_memory </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a89cd8e6f638de0139c3ddad334b2a4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cd8e6f638de0139c3ddad334b2a4d9">&#9670;&nbsp;</a></span>m_asm_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string minidbg::debugger::m_asm_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba207285db39ae79e905ce84b3d4b304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba207285db39ae79e905ce84b3d4b304">&#9670;&nbsp;</a></span>m_asm_vct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structminidbg_1_1asm__head.html">asm_head</a>&gt; minidbg::debugger::m_asm_vct</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>存储汇编信息, 包括起止地址、汇编条目等 </p>

</div>
</div>
<a id="a1cce554a29ebf07ec4ae259facc08af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cce554a29ebf07ec4ae259facc08af4">&#9670;&nbsp;</a></span>m_breakpoints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::intptr_t, <a class="el" href="classminidbg_1_1breakpoint.html">breakpoint</a>&gt; minidbg::debugger::m_breakpoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a702325100d56cf362bcd1668250614d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702325100d56cf362bcd1668250614d7">&#9670;&nbsp;</a></span>m_dwarf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dwarf::dwarf minidbg::debugger::m_dwarf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92f21939a0c73f068627c153828dc2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f21939a0c73f068627c153828dc2a6">&#9670;&nbsp;</a></span>m_elf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">elf::elf minidbg::debugger::m_elf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a4639149d22529617f5a694ee40a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4639149d22529617f5a694ee40a5cf">&#9670;&nbsp;</a></span>m_load_address</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t minidbg::debugger::m_load_address</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a30786c73dd4790c18db6f49802950d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a30786c73dd4790c18db6f49802950d">&#9670;&nbsp;</a></span>m_pid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pid_t minidbg::debugger::m_pid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a180f020ca79e07ea89d05e48434f1696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180f020ca79e07ea89d05e48434f1696">&#9670;&nbsp;</a></span>m_prog_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string minidbg::debugger::m_prog_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17a12eeb3fc31453ba9e54e2c57aafa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a12eeb3fc31453ba9e54e2c57aafa4">&#9670;&nbsp;</a></span>m_src_vct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; minidbg::debugger::m_src_vct</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>存储源代码 </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>include/<a class="el" href="debugger_8hpp_source.html">debugger.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
